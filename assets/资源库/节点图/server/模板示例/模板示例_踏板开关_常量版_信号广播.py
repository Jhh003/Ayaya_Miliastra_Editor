"""
graph_id: server_template_pedal_switch_signal_broadcast_constant_01
graph_name: 模板示例_踏板开关_常量版_信号广播
graph_type: server
description: 教学示例（常量版）：踏板开关在“按下完成/回弹开始”时用信号广播 `是否激活`。与“可配置通用版”不同，本示例把位移距离/速度/最小触发人数/触发器序号/相对位移方向/一次性开关/特效等写成代码常量（字面量），不通过对外暴露的节点图变量配置；仅保留少量隐藏节点图变量用于跨事件保存运行期状态。

节点图变量：
- 原始位置: 三维向量 = (0,0,0)
- 原始旋转: 三维向量 = (0,0,0)
- 按下目标位置: 三维向量 = (0,0,0)
- 运动目标状态: 字符串 = "空"
- 调试_最近一次广播_是否激活: 布尔值 = False
- 是否锁定按下: 布尔值 = False
"""

from __future__ import annotations

import pathlib
import sys

脚本文件路径 = pathlib.Path(__file__).resolve()
节点图根目录 = 脚本文件路径.parents[2]  # 节点图根目录（.../节点图）
服务器节点图目录 = 节点图根目录 / "server"  # 包含 server 侧 `_prelude.py` 的目录
if str(服务器节点图目录) not in sys.path:
    sys.path.insert(0, str(服务器节点图目录))

from _prelude import *  # noqa: F401,F403
from engine.graph.models.package_model import GraphVariableConfig


GRAPH_VARIABLES: list[GraphVariableConfig] = [
    GraphVariableConfig(
        name="原始位置",
        variable_type="三维向量",
        default_value=(0.0, 0.0, 0.0),
        description="记录踏板初始位置。",
        is_exposed=False,
    ),
    GraphVariableConfig(
        name="原始旋转",
        variable_type="三维向量",
        default_value=(0.0, 0.0, 0.0),
        description="记录踏板初始旋转。",
        is_exposed=False,
    ),
    GraphVariableConfig(
        name="按下目标位置",
        variable_type="三维向量",
        default_value=(0.0, 0.0, 0.0),
        description="踏板按下后的目标位置。",
        is_exposed=False,
    ),
    GraphVariableConfig(
        name="运动目标状态",
        variable_type="字符串",
        default_value="空",
        description="记录当前预期的运动完成状态：空/按下/回弹。",
        is_exposed=False,
    ),
    GraphVariableConfig(
        name="调试_最近一次广播_是否激活",
        variable_type="布尔值",
        default_value=False,
        description="调试用：在编辑器中镜像最近一次对外广播的“是否激活”布尔值（True=按下完成广播开启，False=回弹开始广播关闭）。不参与业务逻辑判断。",
        is_exposed=False,
    ),
    GraphVariableConfig(
        name="是否锁定按下",
        variable_type="布尔值",
        default_value=False,
        description="一次性锁定状态：接收端回发确认后锁定按下并禁用触发器，不再回弹。",
        is_exposed=False,
    ),
]


class 模板示例_踏板开关_常量版_信号广播:
    """常量版踏板开关示例：用信号广播踏板“是否激活”状态。

    与 `模板示例_踏板开关_信号广播` 的差异：
    - 位移距离/速度/最小触发人数/触发器序号/相对位移方向/一次性开关/特效等均为“字面量常量”，不对外暴露为节点图变量；
    - 仅将“原始位置/原始旋转/按下目标位置/运动目标状态/调试镜像/锁定状态”保留为隐藏节点图变量，用于跨事件保存运行期状态。

    广播约定：
    - 踏板端在“按下完成”时 `发送信号(信号名="通用踏板开关_状态变化", 是否激活=True)`；
    - 踏板端在“回弹开始”时 `发送信号(..., 是否激活=False)`；
    - 接收端通过监听事件参数 `信号来源实体` 识别发送方；如需一次性锁定，接收端完成联动后回发 `通用踏板开关_激活确认`。
    """

    def __init__(self, game, owner_entity):
        self.game = game
        self.owner_entity = owner_entity

        from app.runtime.engine.node_graph_validator import validate_node_graph

        validate_node_graph(self.__class__)

    # ---------------------------- 事件：实体创建时 ----------------------------
    def on_实体创建时(self, 事件源实体, 事件源GUID):
        """实体创建时：缓存原始位置/旋转，预计算按下目标位置，并初始化运行期状态。"""
        自身实体: "实体" = 获取自身实体(self.game)

        原始位置, 原始旋转 = 获取实体位置与旋转(
            self.game,
            目标实体=自身实体,
        )
        原始位置: "三维向量"
        原始旋转: "三维向量"

        设置节点图变量(
            self.game,
            变量名="原始位置",
            变量值=原始位置,
            是否触发事件=False,
        )
        设置节点图变量(
            self.game,
            变量名="原始旋转",
            变量值=原始旋转,
            是否触发事件=False,
        )

        # ---------------------------- 常量配置（字面量） ----------------------------
        # 位移距离（浮点数常量）
        位移距离: "浮点数" = 1.0
        # 相对位移方向（三维向量常量，使用踏板自身局部坐标系；默认 (0,-1,0) 表示相对向下）
        相对位移方向: "三维向量" = (0.0, -1.0, 0.0)

        方向X: "浮点数"
        方向Y: "浮点数"
        方向Z: "浮点数"
        方向X, 方向Y, 方向Z = 拆分三维向量(
            self.game,
            三维向量=相对位移方向,
        )

        本地右向量: "三维向量" = 获取实体向右向量(self.game, 目标实体=自身实体)
        本地上向量: "三维向量" = 获取实体向上向量(self.game, 目标实体=自身实体)
        本地前向量: "三维向量" = 获取实体向前向量(self.game, 目标实体=自身实体)

        右分量向量: "三维向量" = 三维向量缩放(self.game, 三维向量=本地右向量, 缩放倍率=方向X)
        上分量向量: "三维向量" = 三维向量缩放(self.game, 三维向量=本地上向量, 缩放倍率=方向Y)
        前分量向量: "三维向量" = 三维向量缩放(self.game, 三维向量=本地前向量, 缩放倍率=方向Z)

        右上合成: "三维向量" = 三维向量加法(self.game, 三维向量1=右分量向量, 三维向量2=上分量向量)
        位移方向向量: "三维向量" = 三维向量加法(self.game, 三维向量1=右上合成, 三维向量2=前分量向量)

        位移向量: "三维向量" = 三维向量缩放(
            self.game,
            三维向量=位移方向向量,
            缩放倍率=位移距离,
        )
        目标位置: "三维向量" = 三维向量加法(
            self.game,
            三维向量1=原始位置,
            三维向量2=位移向量,
        )
        设置节点图变量(
            self.game,
            变量名="按下目标位置",
            变量值=目标位置,
            是否触发事件=False,
        )

        设置节点图变量(
            self.game,
            变量名="运动目标状态",
            变量值="空",
            是否触发事件=False,
        )
        设置节点图变量(
            self.game,
            变量名="调试_最近一次广播_是否激活",
            变量值=False,
            是否触发事件=False,
        )
        设置节点图变量(
            self.game,
            变量名="是否锁定按下",
            变量值=False,
            是否触发事件=False,
        )

    # ---------------------------- 事件：进入碰撞触发器时 ----------------------------
    def on_进入碰撞触发器时(self, 进入者实体, 进入者实体GUID, 触发器实体, 触发器实体GUID, 触发器序号):
        """进入碰撞触发器时：满足最小触发人数且当前未处于“按下目标状态”时，启动按下运动。"""
        # 常量：只处理该序号的碰撞触发器
        目标序号: "整数" = 0

        是否目标触发器: "布尔值" = 是否相等(
            self.game,
            输入1=触发器序号,
            输入2=目标序号,
        )
        if 是否目标触发器:
            当前目标状态: "字符串" = 获取节点图变量(
                self.game,
                变量名="运动目标状态",
            )
            是否已处于按下状态: "布尔值" = 是否相等(
                self.game,
                输入1=当前目标状态,
                输入2="按下",
            )
            # 已经在“按下”（包含正在下落/已到位）时，后续进入无需再触发，也无需再计算人数
            if 是否已处于按下状态:
                return

            自身实体: "实体" = 获取自身实体(self.game)
            实体列表 = 获取碰撞触发器内所有实体(
                self.game,
                目标实体=自身实体,
                触发器序号=目标序号,
            )
            当前数量 = 获取列表长度(
                列表=实体列表,
            )

            # 常量：最小触发人数
            最小触发人数: "整数" = 1
            是否达到触发人数: "布尔值" = 数值大于等于(
                self.game,
                左值=当前数量,
                右值=最小触发人数,
            )
            if 是否达到触发人数:
                目标位置: "三维向量" = 获取节点图变量(
                    self.game,
                    变量名="按下目标位置",
                )
                原始旋转: "三维向量" = 获取节点图变量(
                    self.game,
                    变量名="原始旋转",
                )

                # 常量：位移速度
                速度: "浮点数" = 2.0

                设置节点图变量(
                    self.game,
                    变量名="运动目标状态",
                    变量值="按下",
                    是否触发事件=False,
                )

                # 可能存在回弹未结束就再次触发按下：先停止同名运动器，避免停止事件误判
                停止并删除基础运动器(
                    self.game,
                    目标实体=自身实体,
                    运动器名称="踏板回弹定点运动",
                    是否停止所有基础运动器=False,
                )
                停止并删除基础运动器(
                    self.game,
                    目标实体=自身实体,
                    运动器名称="踏板按下定点运动",
                    是否停止所有基础运动器=False,
                )
                开启定点运动器(
                    self.game,
                    目标实体=自身实体,
                    运动器名称="踏板按下定点运动",
                    移动方式="匀速直线运动",
                    移动速度=速度,
                    目标位置=目标位置,
                    目标旋转=原始旋转,
                    是否锁定旋转=True,
                    参数类型="固定速度",
                    移动时间=0.0,
                )

                # 注意：不在此处立即广播“开启”，而是在运动完成时统一广播

    # ---------------------------- 事件：离开碰撞触发器时 ----------------------------
    def on_离开碰撞触发器时(self, 离开者实体, 离开者实体GUID, 触发器实体, 触发器实体GUID, 触发器序号):
        """离开碰撞触发器时：人数不足且当前处于“按下目标状态”时，启动回弹运动。"""
        目标序号: "整数" = 0
        是否目标触发器: "布尔值" = 是否相等(
            self.game,
            输入1=触发器序号,
            输入2=目标序号,
        )
        if 是否目标触发器:
            是否锁定按下: "布尔值" = 获取节点图变量(
                self.game,
                变量名="是否锁定按下",
            )
            if 是否锁定按下:
                return

            自身实体: "实体" = 获取自身实体(self.game)
            实体列表 = 获取碰撞触发器内所有实体(
                self.game,
                目标实体=自身实体,
                触发器序号=目标序号,
            )
            当前数量 = 获取列表长度(
                列表=实体列表,
            )

            最小触发人数: "整数" = 1
            是否人数不足: "布尔值" = 数值小于(
                self.game,
                左值=当前数量,
                右值=最小触发人数,
            )

            当前目标状态: "字符串" = 获取节点图变量(
                self.game,
                变量名="运动目标状态",
            )
            是否处于按下状态: "布尔值" = 是否相等(
                self.game,
                输入1=当前目标状态,
                输入2="按下",
            )

            if 是否处于按下状态:
                if 是否人数不足:
                    原始位置: "三维向量" = 获取节点图变量(
                        self.game,
                        变量名="原始位置",
                    )
                    原始旋转: "三维向量" = 获取节点图变量(
                        self.game,
                        变量名="原始旋转",
                    )
                    速度: "浮点数" = 2.0

                    设置节点图变量(
                        self.game,
                        变量名="运动目标状态",
                        变量值="回弹",
                        是否触发事件=False,
                    )

                    # 回弹开始立刻广播“关闭”
                    发送信号(
                        self.game,
                        信号名="通用踏板开关_状态变化",
                        是否激活=False,
                    )

                    停止并删除基础运动器(
                        self.game,
                        目标实体=自身实体,
                        运动器名称="踏板按下定点运动",
                        是否停止所有基础运动器=False,
                    )
                    停止并删除基础运动器(
                        self.game,
                        目标实体=自身实体,
                        运动器名称="踏板回弹定点运动",
                        是否停止所有基础运动器=False,
                    )
                    开启定点运动器(
                        self.game,
                        目标实体=自身实体,
                        运动器名称="踏板回弹定点运动",
                        移动方式="匀速直线运动",
                        移动速度=速度,
                        目标位置=原始位置,
                        目标旋转=原始旋转,
                        是否锁定旋转=True,
                        参数类型="固定速度",
                        移动时间=0.0,
                    )

    # ---------------------------- 事件：基础运动器停止时 ----------------------------
    def on_基础运动器停止时(self, 事件源实体, 事件源GUID, 运动器名称):
        """基础运动器停止时：若为按下运动完成则广播“开启”，并按需播放特效。"""
        自身实体: "实体" = 获取自身实体(self.game)

        match 运动器名称:
            case "踏板按下定点运动":
                当前目标状态: "字符串" = 获取节点图变量(
                    self.game,
                    变量名="运动目标状态",
                )
                是否激活: "布尔值" = 是否相等(
                    self.game,
                    输入1=当前目标状态,
                    输入2="按下",
                )

                设置节点图变量(
                    self.game,
                    变量名="调试_最近一次广播_是否激活",
                    变量值=是否激活,
                    是否触发事件=False,
                )

                if 是否激活:
                    # 常量：按下完成特效（示例默认配置ID=0，表示不播放或由运行时决定）
                    按下特效配置ID: "配置ID" = 0
                    按下特效挂接点: "字符串" = "Root"
                    播放限时特效(
                        self.game,
                        特效资产=按下特效配置ID,
                        目标实体=自身实体,
                        挂接点名称=按下特效挂接点,
                        是否跟随目标运动=True,
                        是否跟随目标旋转=True,
                        位置偏移=(0.0, 0.0, 0.0),
                        旋转偏移=(0.0, 0.0, 0.0),
                        缩放倍率=1.0,
                        是否播放自带的音效=False,
                    )

                    发送信号(
                        self.game,
                        信号名="通用踏板开关_状态变化",
                        是否激活=True,
                    )
            case "踏板回弹定点运动":
                return
            case _:
                return

    # ---------------------------- 事件：监听接收端回发确认 ----------------------------
    def on_通用踏板开关_激活确认(
        self,
        事件源实体,
        事件源GUID,
        信号来源实体,
        开关GUID,
        是否允许锁定,
    ):
        """接收端回发确认：若本示例被设置为一次性，则锁定按下并禁用触发器。"""
        自身实体: "实体" = 获取自身实体(self.game)
        自身GUID: "GUID" = 以实体查询GUID(
            self.game,
            实体=自身实体,
        )

        是否给本踏板: "布尔值" = 是否相等(
            self.game,
            输入1=开关GUID,
            输入2=自身GUID,
        )
        是否允许锁定_布尔: "布尔值" = 是否允许锁定

        # 常量：是否一次性（需要时可直接改这里，不对外暴露为节点图变量）
        是否一次性: "布尔值" = False

        if 是否给本踏板:
            if 是否允许锁定_布尔:
                if 是否一次性:
                    设置节点图变量(
                        self.game,
                        变量名="是否锁定按下",
                        变量值=True,
                        是否触发事件=False,
                    )

                    目标序号_禁用: "整数" = 0
                    激活关闭碰撞触发器(
                        self.game,
                        目标实体=自身实体,
                        触发器序号=目标序号_禁用,
                        是否激活=False,
                    )

    # ---------------------------- 注册事件处理器 ----------------------------
    def register_handlers(self):
        self.game.register_event_handler(
            "实体创建时",
            self.on_实体创建时,
            owner=self.owner_entity,
        )
        self.game.register_event_handler(
            "进入碰撞触发器时",
            self.on_进入碰撞触发器时,
            owner=self.owner_entity,
        )
        self.game.register_event_handler(
            "离开碰撞触发器时",
            self.on_离开碰撞触发器时,
            owner=self.owner_entity,
        )
        self.game.register_event_handler(
            "基础运动器停止时",
            self.on_基础运动器停止时,
            owner=self.owner_entity,
        )
        self.game.register_event_handler(
            "通用踏板开关_激活确认",
            self.on_通用踏板开关_激活确认,
            owner=self.owner_entity,
        )


if __name__ == "__main__":
    from app.runtime.engine.node_graph_validator import validate_file

    自身文件路径 = pathlib.Path(__file__).resolve()
    是否通过, 错误列表, 警告列表 = validate_file(自身文件路径)
    print("=" * 80)
    print(f"节点图自检: {自身文件路径.name}")
    print(f"文件: {自身文件路径}")
    if 是否通过:
        print("结果: 通过")
    else:
        print(f"结果: 未通过（错误: {len(错误列表)}，警告: {len(警告列表)}）")
        if 错误列表:
            print("\n错误明细:")
            for 序号, 错误文本 in enumerate(错误列表, start=1):
                print(f"  [{序号}] {错误文本}")
        if 警告列表:
            print("\n警告明细:")
            for 序号, 警告文本 in enumerate(警告列表, start=1):
                print(f"  [{序号}] {警告文本}")
    print("=" * 80)
    if not 是否通过:
        sys.exit(1)


