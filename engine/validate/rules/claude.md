## 目录用途
- 提供验证层使用的规则视图与工具函数，包括节点图代码语法/结构规则、端口类型匹配规则、复合节点嵌套规则、数据类型规则和节点挂载规则等，在校验阶段对 Graph Code 与图结构进行统一约束。
- 这里的代码通常与 `engine.configs.rules.*` 中的原始规则结构对应，通过 AST 与节点库视图将底层规则转化为面向“检查流程”的实现。

## 当前状态
- 以纯规则实现和轻量工具函数为主，专注于为 `engine.validate.*` 提供可组合的 `ValidationRule` 与辅助方法。
- 与配置层规则解耦：配置层负责规则与类型体系的权威定义，本目录负责在校验过程中的使用方式与错误信息组织；组件与资源等权威定义集中在 `engine.configs.rules` 与相关注册表中，这里仅通过导入视图进行读取。
- 规则执行会根据节点图文件路径/元数据推断 graph scope（server/client），并据此选择对应作用域的节点库视图参与校验（端口名/端口类型/必填入参等），避免 server/client 同名节点在端口定义不兼容时发生“互相覆盖”导致的误报与缓存不稳定。
- 节点图代码侧的原子规则覆盖布尔条件来源、内联语法限制、变量声明、信号参数名合法性、类型名合法性以及禁止直接在 Graph Code 中写 Python 式常量赋值等约束；图结构与综合规则基于序列化图模型检查端口类型匹配、长连线、未使用结果与不可达代码等问题。节点图变量相关检查（声明合法性与类型合法性）仅消费代码级 `GRAPH_VARIABLES`。信号参数名规则会解析顶层字符串常量（含注解赋值）作为“信号名”输入来源，若值为信号 ID 会报错提醒改用信号名称，避免通过命名常量绕过校验。`if` 条件仍禁止内联 Python 比较（`==`/`!=`/`is` 等），必须使用比较类节点输出布尔值或先赋值后再分支；同时为提升 UI 可读性，新增规则禁止在 `if` 条件中直接写 `逻辑非运算(...)`（要求写成正向条件），并对 `if 是否相等(布尔值, True/False)` 给出 warning 提醒冗余比较；另提供“事件节点多流程出口”warning，帮助发现事件入口意外分叉。
- 节点图代码侧的原子规则覆盖布尔条件来源、内联语法限制、变量声明、信号参数名合法性、类型名合法性以及禁止直接在 Graph Code 中写 Python 式常量赋值等约束；图结构与综合规则基于序列化图模型检查端口类型匹配、长连线、未使用结果与不可达代码等问题。节点图变量相关检查（声明合法性与类型合法性）仅消费代码级 `GRAPH_VARIABLES`。信号参数名规则会解析顶层字符串常量（含注解赋值）作为“信号名”输入来源，若值为信号 ID 会报错提醒改用信号名称，避免通过命名常量绕过校验。`if` 条件允许使用 `not` 对布尔表达式取反；但仍禁止在 `if` 条件中直接书写 Python 比较（`==`/`!=`/`is` 等），必须使用比较类节点输出布尔值或先赋值后再分支。对于函数体内 `x: "布尔值" = ...` 这种带类型注解的变量，校验会将其视为可用于 `if` 条件的布尔来源，避免被迫写 `是否相等(x, True)` 的绕法。
- 复合节点规则（`composite_types_nesting.py`）覆盖复合节点“引脚类型 + 禁止复合嵌套”的关键约束，并以**真实语义来源**为权威：
  - payload 格式：读取 `COMPOSITE_PAYLOAD_JSON` 中的 `virtual_pins/sub_graph` 做校验；
  - 类格式：读取方法体内 `流程入/流程出/数据入/数据出` 的 pin_marker 扫描结果做校验（而不是依赖装饰器参数）。
  - 非 payload/类格式会直接报错（`COMPOSITE_FORMAT_UNSUPPORTED`），不再兼容旧函数式复合节点格式，避免闭环分裂。
  允许的对外引脚类型为：基础类型/列表类型/字典与“流程”。**泛型仅作为“未设置”的占位**，在保存/成品校验阶段不允许出现在任何对外引脚上（包括：泛型/列表/泛型列表/泛型字典）。严禁旧别名“通用/Any”等，并禁止使用 Python 内置类型名（int/float/str/bool/list/dict），要求统一使用中文端口类型。
- 代码结构规则额外覆盖“节点调用必填入参”：基于节点库静态输入端口清单，禁止漏传必填端口（流程端口与变参占位端口除外），并对结构体类节点的“结构体名”取值做存在性校验，避免静默错误。

## 注意事项
- 不在文档字符串或注释中暴露外部知识库或文档系统的具体路径，引用外部资料时保持在“内部规则文档”等抽象描述层级。
- 保持与配置层规则结构和命名的一致性，避免在此层重新硬编码规则常量或重复实现同类数据结构。
- 类型体系（规范中文类型名、结构体/变量允许集合、别名字典解析等）的唯一事实来源为 `engine/type_registry.py`；验证层不得维护平行类型清单，历史导入路径仅保留兼容转发。
- 新增或调整规则时，优先通过现有的 AST 工具、节点库视图与 Schema 视图获取信息，避免在规则内部直接依赖上层 UI、工具或资源加载逻辑。
- GUID 类型在引擎内就是数字 ID（可用字符串包裹数字）形式的标识，纯数字是正常形态；如遇编辑器对数字 GUID 报格式警告，可在使用侧按需忽略该静态检查。

## 补充约定
- 类型占位（`datatypes_typing.py`）仅用于静态检查；节点图“类/文件校验入口”统一由 `engine.validate.node_graph_validator` 提供（runtime 侧仅做 re-export）。

## 子模块概览
- 原子代码规则（M2 层）：`code_syntax_rules.py` / `code_structure_rules.py` / `code_quality_rules.py` 聚焦"禁止列表/字典字面量""布尔条件来源必须为布尔节点""禁止内联 if/算术""长连线/未使用结果/不可达代码""发送信号参数名必须来源于信号定义"等约束。`code_structure_rules.py` 为稳定入口，具体实现已按规则域拆分到 `code_structure/` 子包中；提供 `IfBooleanRule`、`EventNameRule`、`TypeNameRule`、`SignalParamNamesRule` 等核心规则；`NoListDictLiteralRule` 禁止在所有节点图（包括普通节点图和复合节点）中直接使用 `[]` 或 `{}` 字面量定义列表/字典（包括出现在函数调用参数、表达式内部等任意位置），要求使用【拼装列表】【建立字典】等节点代替；`TypeNameRule` 同时理解基础类型名、列表类型名、结构体类型名以及形如"X-Y字典"或"X_Y字典"的字典别名类型，并要求别名中的键/值类型本身落在受支持的数据类型集合内；`NoLiteralAssignmentRule` 统一限制直接将 Python 字面量赋值给变量，并约定仅允许带中文类型注解的"命名常量"声明作为节点输入端的常量来源，同时禁止通过 `目标变量 = 命名常量` 这类别名赋值在 Graph Code 中间层复制常量值，鼓励使用【获取局部变量】/【设置局部变量】等节点管理运行时状态；`UnusedQueryOutputRule` 检测声明但未使用的变量（支持简单赋值 `x = 查询(...)` 和带类型注解的赋值 `x: "类型" = 查询(...)` 两种形式），级别为 error，避免产生无用的"孤立节点"。
  - 已知节点必须传 game：只要函数名在节点库中，就必须显式传入 `self.game/game`（支持位置参数或 `game=self.game` 关键字形式），避免漏传 game 绕过部分静态规则并在运行期报错。
  - 【获取局部变量】调用结果必须二元解包或显式下标选择输出端口（句柄/值），避免“把二元返回当作单值”潜伏到运行期。
  - 事件相关：除 `EventNameRule` 校验事件名合法性外，`EventHandlerNameRule` 进一步要求“内置事件”的回调命名必须为 `on_<事件名>`（严格一致），避免 `on_定时器触发时_XXX` 这类看似新事件但实际复用同一内置事件的写法绕过规范；信号事件不强制回调名。
  - `OnMethodNameRule` 对所有类结构节点图生效：只要方法名以 `on_` 开头，后缀就必须为内置事件名或已定义信号名/ID（即使未注册也会报错），防止伪事件入口潜伏。
  - 额外包含“未知节点函数名”约束：当代码出现 `某函数(self.game, ...)` 形态但该函数名不在节点库中，会直接报错，避免拼写错误或不存在节点名被静默跳过。
- `code_quality_rules.py` 额外包含拉取式执行器风险提示 `PullEvalReevaluationHazardRule`（warning）：当【设置自定义变量】写入后，后续流程节点仍依赖同一个【获取自定义变量】节点实例时，报告 `CODE_PULL_EVAL_REEVAL_AFTER_WRITE`，用于提前暴露“重复求值导致条件/数值偏移”的易踩坑；规则会将跨块数据节点副本规约到 `original_node_id`，避免在 for/match 等多块结构中漏报。
- 组合规则（M3 层）：`code_port_types_match.py`、`composite_types_nesting.py` 等模块在端口类型匹配、复合节点嵌套与泛型类型使用等方面补充更高层次的检查，其中端口类型匹配规则会结合节点库中声明的端口类型与枚举候选值，对 Graph Code 中的常量与变量类型进行约束校验。
  - 端口类型匹配会额外对基础算术节点（如加减乘除）的“左值/右值”执行语义级限制：禁止把“布尔值”当作数值参与算术运算，即便节点端口写成了“泛型”也会报错，避免类型语义被隐式滥用。
- 规则入口由 `engine.validate.api.validate_files()` 统一装配：`_build_rules()` 会按配置开关与“是否复合节点文件”选择规则集，并通过 `ValidationPipeline` 顺序执行；是否启用严格实体入参校验由配置键 `STRICT_ENTITY_INPUTS_WIRE_ONLY` 控制（由 `validate_files(..., strict_entity_wire_only=...)` 参数注入）。
- `node_index.py` 提供节点库速查与缓存清理工具（`clear_node_index_caches()`），并以“节点库 key 的名称部分（`类别/名称` → `名称`）”作为 Graph Code 的可调用名来源，从而兼容管线注入的别名（如 `make_valid_identifier(name)`）；`ast_utils.py` 负责 AST 解析、源码缓存与统一生成 `EngineIssue` 的辅助函数；涉及节点图代码特有语义时，可以依赖 `engine.graph.utils` 提供的纯函数工具（如复合节点实例提取），避免在规则内部重复实现解析逻辑。
- 类型名相关规则负责检查节点图代码中的中文类型注解以及代码级 `GRAPH_VARIABLES` 声明中的图变量类型是否落在引擎支持的数据类型集合内（含基础类型、列表类型、结构体、枚举、泛型等），避免出现诸如“任意”这类未注册的自由类型名，并统一约定仅使用“泛型”这一宽泛类型标识；docstring 中的“节点图变量”段落仅作说明，校验与声明完全忽略。


